## JSON on the Web

- JSON `Marshal` vs `UnMarshal`
- Be careful while marshalling `rune`
- Sending JSON in HTTP API response, converting go struct into JSON format and vice versa
- `http.ServeMux`, Creating a HTTP web server

## Authentication, Authorization

- **Authentication** - verifies who you are (verifies that no-one is impersonating you)
- **Authorization** - Defines what we can do
- How can we add Authentication for APIs ?
  - One way is to do it via **Authorization** Header
  - Two common authorization schmes
  ```java
  Authorization: Basic QWxhZGRpbjpPcGVuU2VzYW1l
  Authorization: Bearer <token>
  ```
  - In **Basic** Authorization we will send "username:password" encoded in base64 format with every request
    - **Never use Basic with http** since we are sending username and password, only **https** is recommended
    - `req.BasicAuth()` in go will return the username and password, you don't have to handle the base64 decoding part
  - In **Bearer** we can send tokens like JWT.
  - To know more on Authorization Header - https://beeceptor.com/docs/concepts/authorization-header/

## Storing Passwords In DB - Hashing

- Never store plain passwords
- Store password by Hashing them (hashing is irreversible). Even if the db gets leaked original password can't be recovered
- Go packages for hashing the data - `sha256`, `bcrypt`
- `shasum -a 256 go1.24.2.darwin-amd64.pkg`
- `echo -n "password" | shasum -a 256`

## Digital Signature

- It's like digital version of signing a document with pen - but mathematically secure.
- Use it for data **Integrity**(data is not altered) & **Authenticity**(msg came from expected person).
- **Sender**
  - Hash the message
  - Sign the Hash with sender **private key**
  - Send {message, signature}
- **Receiver**
  - Decrypt the signature using sender **public key**
  - Generate the hash of message
  - Compare both the hash values
- go package `ECDSA`

## HMAC

- Hash-based Message Authentication Code
- `hmac = Hash(message + secret)`
- secret is shared between two parties who trust each other
- Sender sends {hmac,message}
- Receiver **generates** the hmac of received message using same secret key and compares new hmac signature with received hmac code
- to prevent **faked bearer tokens**, use this hmac cryptographic "signing"

## Bearer Tokens

- added in http specification with OAUTH2
- uses authorization header & keyword "Bearer"

## JWT - JSON Web Tokens

- {JWT standard fields - header}.{Your fields - payload}.{Signature}
- `base64UrlEncode(header) + "." + base64UrlEncode(payload) + "." + signature`
- base64 encoding is used because it will not generate periods(.) and we want our jwt token to be divided into 3 parts
- [jwt.io](https://jwt.io)
- anyone can read the payload or header since these are just base64 encoded strings
- But the signature is generated using `HMAC SHA512`. hmac code is generated by combining `payload + secret` so no body else can fake it
- We have to verify every jwt token that we receive on backend. by regenerating the hmac code again(payload + secret). If it matches we can ensure that token is issued by us.
- Embedding usecase - [check here](internal/05_jwt_auth_api.go)
- [Authenticating HTTP APIs with JWT](internal/05_jwt_auth_api.go)
- **We can write a common middleware to validate the token, and if we want to pass the jwt payload (Claims) that we got by parsing the token to the main handler, we can pass it using the req Context.**

#### Storing JWT in Cookies

- We can store the token in browser Cookies if the APIs are being consumed by the client app running on a Web Browser.
  - Set Cookie during login `http.SetCookie(w, cookie)`
  - Cookies will be added to the request automatically so we can easily retrieve it using `req.Cookie("name")`
- Storing jwt in cookies is not ideal for mobile apps

## base64

- Encode binary data into text. we typically use this encoding for transferring binary data over text based protocol like HTTP
- binary data - images, other files
- Read more here - https://sumanth.netlify.app/blog/03-charsets-encodings/
- go package `base64`
  - base64.URLEncoding
  - base64.StdEncoding

## ðŸ’Ž Add Authentication to Website - Exercise

- when user hits the '/' root url, we will return the html for registration page
  - User can enter username and password and hit enter, and the action for form is specified as POST in register form `<form action="/register" method="POST">`
- `/register` is a POST call used for registering a new user.
  - Store the new username and hashed password in db and redirect user to Login page
  - `http.Redirect(w, r, "/login-page", http.StatusSeeOther)`
- `/login-page` is a GET request which returns the html for login form
  - input username and password and submit. the login req will go to `/login` post method
  - If the username and password matches then set the cookie and navigate user to dashboard
-
